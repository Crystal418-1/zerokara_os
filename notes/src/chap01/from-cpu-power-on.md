# 从CPU上电开始


> CPU刚刚通上电的时候，以实模式启动。

+ 什么是实模式？为什么是实模式？

    实模式是Intel 8086的运行模式。

    这是一个历史包袱。
    Intel第一款具有跨时代意义的芯片 —— Intel 8086 —— 在1978年发布。这是Intel的第一款16位处理器，有16根数据线和20根地址线，不仅如此，还能同时处理16位数据和8位数据，可寻址空间也高达1MB（\\(2^{20}\\)）。这也是 **第一款** 使用x86指令集架构的CPU，几乎是日后AMD与Intel所有处理器的 **基石**。

    Intel是商业公司，而不是开源社区，这意味着Intel的产品必须向后兼容 —— 否则就没人买你的产品了。于是乎，等到1985年Intel推出了80386处理器 —— 第一款32位x86处理器后 —— 它还是需要兼容16位的程序，以至于Intel为了让产品的价格更加亲民，还推出了80386L —— 一款拥有32位地址线（\\(2^{32}=4GB\\)）但是只能跑16位程序的阉割版80386。所有这些产品都可以运行从8086移植过来的程序。

    在8086的时期，压根儿没有什么实模式保护模式的说法，就一种模式，那就是程序里面写的地址是多少就直接在哪里跑。*谁都想不到计算机今后会发展地这么厉害*。随着软件的发展，软件数量越来越多，多道程序的概念也提出了，同一个内存上面同时存在着多个程序。这就导致了一个问题：程序里的内存地址在编译时期早已确定，但是在运行时期却有其他程序会与自己竞争同一个内存地址。比如，程序A在编译期确定了某个函数的地址是`0x123456`，而程序B在编译期确定了自己的main函数也是放在这个位置，这就会导致冲突。

    为了解决这种冲突，出现了“保护模式”的概念。所谓保护模式，就是程序里写的地址不再是物理地址，而是虚拟地址。保护模式是在80386时期提出的。那个时候，80386还需要为曾经运行在8086上的程序服务。8086处理器在开机的时候就是全裸的，没有什么乱七八糟的内存保护虚拟内存等，80386干脆把这一点也继承过来，服务更多的用户（恰更多的钱）。

    于是，下一代Intel的80486为了向后兼容80386，也把这一点继承了过来…… 以后的所有x86结构的CPU都继承了这一点。只是谁都想不到计算机会发展地这么快，以至于64位都出来了，内存动辄以GB为单位，时钟周期以GHz为单位，寻址空间更是大到了一辈子都用不了那么多的地步 —— 当然，这也有可能是人类的短视。我们生活的世界限制了我们的想象力，只有天才才敢于突破桎梏，做出常人概念之外的事情（也有可能是疯子）。

    因此，所谓实模式就是一个由于人类的短视而不得不永远背上的历史包袱。需要注意的是，保护模式的提出和32位处理器的出现并没有什么直接联系，只是时间上刚刚好撞到了而已。所以我们常说的保护模式是16位、实模式是32/64位，只是一个巧合。

    不过，作为高层的软件设计者，则无需关心这些内容。只有学习操作系统的启动过程时才需要了解。

> 实模式的内存计算方式是 `段基址 << 4 + 段内偏移`

+ 什么是段基址？什么段内偏移？为什么是这么计算的？

    同样的，看待一个历史问题要从历史背景出发。学校不愿意教，我们就自己学。

    在8086之前的8080时期，处理器是8位的，，而地址线是16根，最大寻址空间是 \\(2^{16} = 64K\\)，寻址用两个8位寄存器，一个寄存器表示16位地址的前8位，另一个寄存器表示后8位。到了8086时期，地址线扩展到了20根，寻址空间扩展到了 \\(2^{20} = 1M\\)。为什么是20根？因为 \\(1M\\)在当时看来已经大到用不完了，没必要弄一个32根的地址线（而且当时能不能造出 \\(4GB\\) 的存储器也是一个问题）—— 又是人类的短视。

  + 寄存器明明是16位的，地址却是20位的，这应该怎么计算地址呢？

    当时实现的方式是，使用两个数值，一个16位数值先左移4位变成20位的数值，再与另一个16位数值相加，也就是 `段基址 << 4 + 段内偏移`。所谓段基址，由 **段寄存器** 提供，而段内偏移量则由程序提供。

  + 什么是段寄存器？

    8086的段寄存器和我们现在的段寄存器的意思不一样。我们在这里只说明8086的段寄存器。

    由上所示，通过段基址和段内偏移的配合，16位的处理器可以访问到20位的地址。段寄存器在8086时期就是存储段基址的一些特殊的寄存器 —— 那个时候存放的是地址，没有其他权限控制之类乱七八糟的东西。通过不同的段寄存器访问地址`ip`，实际上访问到的是 `段基址 << 4 + 段内偏移`。那个时候的段寄存器有四个，分别指向不同的段：

    1. `cs`：`code segment`
    2. `ds`: `data segment`
    3. `ss`: `stack segment`
    4. `es`: `extra segment`

    名字就可以看出来是干什么的。

> CPU的第一条指令通过 `CS:IP` 取得。在8086中，此时 `CS=0xFFFF`，`IP=0x0000`，即第一条指令地址为`0xFFFF0`；在80286中，`CS=0xF000`，`IP=0xFFF0`，计算处的地址结果仍然是`0xFFFF0`。在80386中，该地址变为了`0xFFFFFFF0`，即 \\(4GB\\) 往下16字节的位置。

+ 为什么是`CS:IP`？为什么是`0xFFFF0`？什么是`BIOS`？什么是`ROM`？

  + 为什么是 `CS:IP`？

    `IP` 是 `instruction pointer` 的意思。`CS` 寄存器指向内存中代码段基址，`IP` 用来确定要执行的下一条指令的内存地址。

    那 `PC` 是什么呢？`PC`是非intel厂家对`IP`的称呼。也就是说这两个是一个东西。

    冯‥诺依曼体系结构计算机本质上就是一条无限长的小纸袋和一个移来移去的小黑盒。CPU从开机开始就重复读取下一条指令、执行指令的过程。

  + 为什么是`0xFFFF0`和`0xFFFFFFF0`？什么是`BIOS`？

    `BIOS` 是 `Basic Input Output System` 的意思。它是个人电脑启动时的第一个软件，专门负责系统硬件的各种参数设定，烧写在ROM芯片中。它将首先识别主板上的各种重要硬件(POST)，然后按照预设顺序识别各个存储器上的操作系统的引导文件。

    ROM一般是只读的、稳定的。不过，现代计算机存储BIOS的芯片显然是有一定的可读写次数的。

    由于不同的计算机厂商生产的计算机所带的外设不一样，因此，`BIOS`的大小也不一致。若将`BIOS`放在地址`0x00000`处，则用户程序开始地址就变得很不确定（因为不知道`BIOS`占的空间究竟多大）。将这个地址放在内存的顶部（地址从下到上变大）就能有效解决这个问题。因此，规定，将计算机的第一条指令置于`0xFFF....F0`处，再使用一条跳转指令跳转到具体的`BIOS`处。

    > 内存空洞：通常认为内存是连续编址的，但是其实不是。计算机组成原理这门课程里有提到过，假如用户只有 \\(32K\\) 内存，那么，内存编址的范围就是 `0x00000 - 0x07FFF`，从`0x08000`开始到`0xEFFFF`其实是没有内存的。因此，可以把这部分内存映射到其他`RAM`等存储设备处。

> BIOS会检测硬件是否正常工作，同时从`0x00000`开始设置BIOS的中断向量表。

+ 为什么是`0x00000`处设置中断向量表？什么是中断向量表？

    CPU通过中断来执行异常处理与其他突发事件。所有的这些中断对应的中断处理例程的访问地址放在了一张中断向量表内，CPU可以通过这张表来对中断执行对应的处理。

    对于8086，中断向量表放置在内存0处，从`0000:0000`到`0000:03FF`存放着1024个单元的中断向量表。

    为什么呢？

    为什么呢？为什么是放在`0x00000`呢？

    **我猜想**，大概是因为，中断向量表的大小是固定的，而用户程序的大小是不固定的，把中断向量表放在地址0处，可以确定用户程序的开始位置，但是把用户程序放在地址0处，就没办法确定中断向量表的位置了。

> 从CPU上电开始直到BIOS工作结束这一段时间都不是操作系统能控制的。从引导扇区开始，就进入了操作系统的控制范围了。

+ 什么是引导扇区

    引导扇区一般只有一个扇区大小（512字节）。它的主要目的是把操作系统内核读入内存，然后跳转到内核的第一条指令开始执行。

> 引导扇区会被读取到内存`0x07c00`处。这之后，`CS`被设为`0x07C0`，`IP`被设为`0x0000`，开始跳转到`0x7C00`处执行引导程序。

+ 为什么是`0x07c00`呢？

    又是一个历史遗留问题。这个地址来自于Intel的第一代个人电脑芯片8088。8088本身需要`0x0000-0x03FF`的空间（正好1024的大小），因此可以使用的内存为`0x0400-0x7FFF`。为了把更多的空间留给操作系统，引导扇区就被加载到了`0x7FFF - 512 - 512 + 1 = 0x7C00`处了（引导扇区的代码自己也会产生数据，需要多出来512字节进行保存）。从那以后，为了向后兼容，这一点就固定下来了。

+ 什么是引导程序呢？

    引导程序是引导操作系统的程序。BIOS在自检（POST）后，会按照预定顺序寻找存储器上的引导文件，将对应磁盘的第一个扇区的引导程序导入到`0x7C00`处。这一段程序称之为主引导记录（Master Boot Record）。这一段记录不依赖于任何操作系统，并且是可变的，因此可以同时实现多个系统共存。它的主要任务是引导某个分区上的第二阶段引导程序，例如`GRUB`等。

    为什么需要两个分区进行引导呢？

    因为最开始的时候，一个分区已经够用了。但是操作系统越来越复杂，一个分区慢慢就不够用了，所以就有了第二阶段的引导程序。

**********

> 看到这里，理论储备的地方已经差不多了，再往下，就必须要结合具体的代码进行学习了。
