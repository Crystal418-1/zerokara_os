# 理论储备

## 什么是操作系统

要写一个操作系统内核，首先要明白什么是操作系统。

说白了，操作系统就是一个环境，一个分配计算机资源的软件。

最开始的时候，世界上是没有操作系统的，计算机也不像今天这么强大。人们把一坨一坨记录着程序的打孔卡片送进小房间，然后等待运行结果从另一个小房间打印出来。这个过程中的时间基本上都被一个人用掉了，必须要等这个人搞定了才能换下一个人，这肯定是不合理的。于是，出现了联机批处理系统，把作业一批一批地输入计算机、一批一批地计算，节省了大家的时间。

后来，计算机越来越快，导致这边刚刚读完卡片、那边就把结果算好了，大量的宝贵的计算机时间浪费在了扫描小卡片和打印运算结果上了。于是，脱机批处理技术在这个时候出现的。但是这个时候，CPU一次还是只能运行一个程序，这个程序运行到一半需要I/O的时候，还是只能停下来发呆，而I/O比起CPU又极其慢。于是，为了压榨CPU，多道程序系统出现了。在这个阶段，计算机一次读入多个程序，当一个程序准备进行I/O的时候，CPU就保存它的现场，马上切换到另一个程序，等到I/O结束的时候，再换回来。支持CPU和I/O分别运作的技术是通道技术，通道专门负责进行I/O操作，等到I/O完毕的时候，它就告诉CPU说I/O已经好了。

再然后，出现了分时技术，多个人可以同时使用计算机并且感觉不到计算机正在被别人使用；再然后，出现了实时系统；再然后，出现了各种各样其他的系统……

当然，各种各样的系统有其各自的设计目的，例如飞机上使用实时系统、个人电脑使用分时系统等；为不同设备设计的系统也不一样，比如个人电脑可以为了操作体验牺牲性能，而服务器总是要以性能优先等。操作系统就是为了合理分配计算机资源使之适用于各种各样的目的、并且为运行其上的软件提供一个运行时环境而诞生的。这里的计算机资源不仅包括硬件资源，也包括软件资源。

> 随着时代的发展，硬件在不断更新换代，操作系统也在不断演化，操作系统的功能会因为应用场景的不同而具有不同的特点，但它的根本目的依然是为了方便人们对硬件设备的使用和交互。
>
> ——《一个64位操作系统的设计与实现》1.1 什么是操作系统

## 从CPU刚刚通电开始

> CPU刚刚通上电的时候，以实模式启动。

+ 什么是实模式？为什么是实模式？

    实模式是Intel 8086的运行模式。

    这是一个历史包袱。
    Intel第一款具有跨时代意义的芯片 —— Intel 8086 —— 在1978年发布。这是Intel的第一款16位处理器，有16根数据线和20根地址线，不仅如此，还能同时处理16位数据和8位数据，可寻址空间也高达1MB（\\(2^{20}\\)）。这也是 **第一款** 使用x86指令集架构的CPU，几乎是日后AMD与Intel所有处理器的 **基石**。

    Intel是商业公司，而不是开源社区，这意味着Intel的产品必须向后兼容 —— 否则就没人买你的产品了。于是乎，等到1985年Intel推出了80386处理器 —— 第一款32位x86处理器后 —— 它还是需要兼容16位的程序，以至于Intel为了让产品的价格更加亲民，还推出了80386L —— 一款拥有32位地址线（\\(2^{32}=4GB\\)）但是只能跑16位程序的阉割版80386。所有这些产品都可以运行从8086移植过来的程序。

    在8086的时期，压根儿没有什么实模式保护模式的说法，就一种模式，那就是程序里面写的地址是多少就直接在哪里跑。*谁都想不到计算机今后会发展地这么厉害*。随着软件的发展，软件数量越来越多，多道程序的概念也提出了，同一个内存上面同时存在着多个程序。这就导致了一个问题：程序里的内存地址在编译时期早已确定，但是在运行时期却有其他程序会与自己竞争同一个内存地址。比如，程序A在编译期确定了某个函数的地址是`0x123456`，而程序B在编译期确定了自己的main函数也是放在这个位置，这就会导致冲突。

    为了解决这种冲突，出现了“保护模式”的概念。所谓保护模式，就是程序里写的地址不再是物理地址，而是虚拟地址。保护模式是在80386时期提出的。那个时候，80386还需要为曾经运行在8086上的程序服务。8086处理器在开机的时候就是全裸的，没有什么乱七八糟的内存保护虚拟内存等，80386干脆把这一点也继承过来，服务更多的用户（恰更多的钱）。

    于是，下一代Intel的80486为了向后兼容80386，也把这一点继承了过来…… 以后的所有x86结构的CPU都继承了这一点。只是谁都想不到计算机会发展地这么快，以至于64位都出来了，内存动辄以GB为单位，时钟周期以GHz为单位，寻址空间更是大到了一辈子都用不了那么多的地步 —— 当然，这也有可能是人类的短视。我们生活的世界限制了我们的想象力，只有天才才敢于突破桎梏，做出常人概念之外的事情（也有可能是疯子）。

    因此，所谓实模式就是一个由于人类的短视而不得不永远背上的历史包袱。需要注意的是，保护模式的提出和32位处理器的出现并没有什么直接联系，只是时间上刚刚好撞到了而已。所以我们常说的保护模式是16位、实模式是32/64位，只是一个巧合。

    不过，作为高层的软件设计者，则无需关心这些内容。只有学习操作系统的启动过程时才需要了解。

> 实模式的内存计算方式是 `段基址 << 4 + 段内偏移`

+ 什么是段基址？什么段内偏移？为什么是这么计算的？

    同样的，看待一个历史问题要从历史背景出发。学校不愿意教，我们就自己学。

    在8086之前的8080时期，处理器是8位的，，而地址线是16根，最大寻址空间是 \\(2^{16} = 64K\\)，寻址用两个8位寄存器，一个寄存器表示16位地址的前8位，另一个寄存器表示后8位。到了8086时期，地址线扩展到了20根，寻址空间扩展到了 \\(2^{20} = 1M\\)。为什么是20根？因为 \\(1M\\)在当时看来已经大到用不完了，没必要弄一个32根的地址线（而且当时能不能造出 \\(4GB\\) 的存储器也是一个问题）—— 又是人类的短视。

  + 寄存器明明是16位的，地址却是20位的，这应该怎么计算地址呢？

    当时实现的方式是，使用两个数值，一个16位数值先左移4位变成20位的数值，再与另一个16位数值相加，也就是 `段基址 << 4 + 段内偏移`。所谓段基址，由 **段寄存器** 提供，而段内偏移量则由程序提供。

  + 什么是段寄存器？

    8086的段寄存器和我们现在的段寄存器的意思不一样。我们在这里只说明8086的段寄存器。

    由上所示，通过段基址和段内偏移的配合，16位的处理器可以访问到20位的地址。段寄存器在8086时期就是存储段基址的一些特殊的寄存器 —— 那个时候存放的是地址，没有其他权限控制之类乱七八糟的东西。通过不同的段寄存器访问地址`ip`，实际上访问到的是 `段基址 << 4 + 段内偏移`。那个时候的段寄存器有四个，分别指向不同的段：

    1. `cs`：`code segment`
    2. `ds`: `data segment`
    3. `ss`: `stack segment`
    4. `es`: `extra segment`

    名字就可以看出来是干什么的。

> CPU的第一条指令通过 `CS:IP` 取得。在8086中，此时 `CS=0xFFFF`，`IP=0x0000`，即第一条指令地址为`0xFFFF0`；在80286中，`CS=0xF000`，`IP=0xFFF0`，计算处的地址结果仍然是`0xFFFF0`。在80386中，该地址变为了`0xFFFFFFF0`，即 \\(4GB\\) 往下16字节的位置。

+ 为什么是`CS:IP`？为什么是`0xFFFF0`？什么是`BIOS`？什么是`ROM`？

  + 为什么是 `CS:IP`？

    `IP` 是 `instruction pointer` 的意思。`CS` 寄存器指向内存中代码段基址，`IP` 用来确定要执行的下一条指令的内存地址。

    那 `PC` 是什么呢？`PC`是非intel厂家对`IP`的称呼。也就是说这两个是一个东西。

    冯‥诺依曼体系结构计算机本质上就是一条无限长的小纸袋和一个移来移去的小黑盒。CPU从开机开始就重复读取下一条指令、执行指令的过程。

  + 为什么是`0xFFFF0`和`0xFFFFFFF0`？什么是`BIOS`？

    `BIOS` 是 `Basic Input Output System` 的意思。它是个人电脑启动时的第一个软件，专门负责系统硬件的各种参数设定，烧写在ROM芯片中。它将首先识别主板上的各种重要硬件(POST)，然后按照预设顺序识别各个存储器上的操作系统的引导文件。

    ROM一般是只读的、稳定的。不过，现代计算机存储BIOS的芯片显然是有一定的可读写次数的。

    由于不同的计算机厂商生产的计算机所带的外设不一样，因此，`BIOS`的大小也不一致。若将`BIOS`放在地址`0x00000`处，则用户程序开始地址就变得很不确定（因为不知道`BIOS`占的空间究竟多大）。将这个地址放在内存的顶部（地址从下到上变大）就能有效解决这个问题。因此，规定，将计算机的第一条指令置于`0xFFF....F0`处，再使用一条跳转指令跳转到具体的`BIOS`处。

    > 内存空洞：通常认为内存是连续编址的，但是其实不是。计算机组成原理这门课程里有提到过，假如用户只有 \\(32K\\) 内存，那么，内存编址的范围就是 `0x00000 - 0x07FFF`，从`0x08000`开始到`0xEFFFF`其实是没有内存的。因此，可以把这部分内存映射到其他`RAM`等存储设备处。

> BIOS会检测硬件是否正常工作，同时从`0x00000`开始设置BIOS的中断向量表。

+ 为什么是`0x00000`处设置中断向量表？什么是中断向量表？

    CPU通过中断来执行异常处理与其他突发事件。所有的这些中断对应的中断处理例程的访问地址放在了一张中断向量表内，CPU可以通过这张表来对中断执行对应的处理。

    对于8086，中断向量表放置在内存0处，从`0000:0000`到`0000:03FF`存放着1024个单元的中断向量表。

    为什么呢？

    为什么呢？为什么是放在`0x00000`呢？

    **我猜想**，大概是因为，中断向量表的大小是固定的，而用户程序的大小是不固定的，把中断向量表放在地址0处，可以确定用户程序的开始位置，但是把用户程序放在地址0处，就没办法确定中断向量表的位置了。

> 从CPU上电开始直到BIOS工作结束这一段时间都不是操作系统能控制的。从引导扇区开始，就进入了操作系统的控制范围了。

+ 什么是引导扇区

    引导扇区一般只有一个扇区大小（512字节）。它的主要目的是把操作系统内核读入内存，然后跳转到内核的第一条指令开始执行。

> 引导扇区会被读取到内存`0x07c00`处。

+ 为什么是`0x07c00`呢？

    又是一个历史遗留问题。这个地址来自于Intel的第一代个人电脑芯片8088。8088本身需要`0x0000-0x03FF`的空间（正好1024的大小），因此可以使用的内存为`0x0400-0x7FFF`。为了把更多的空间留给操作系统，引导扇区就被加载到了`0x7FFF - 512 - 512 + 1 = 0x7C00`处了（引导扇区的代码自己也会产生数据，需要多出来512字节进行保存）。从那以后，为了向后兼容，这一点就固定下来了。

> 这之后，`CS`被设为`0x07C0`，`IP`被设为`0x0000`，开始跳转到`0x7C00`处执行引导程序。
